<!DOCTYPE HTML>
<html lang="en">
  <head>
    <title>Raspberry Pi - minimal network security setup for a headless Pi</title>
    <link rel="stylesheet" type="text/css" href="https://www.ivankovic.me/css/style.css" media="screen">
    <link rel="icon" href="/favicon.ico">
    <meta charset="utf-8">
<meta name="description" content="">
<meta name="viewport" content="width=device-width, initial-scale=1">

    <script>
      function toggle() {
        menu = document.getElementById('menu')
        menu.style.display = (menu.style.display == 'none' || menu.style.display == '' ? 'block' : 'none')
      }
    </script>
  </head>
  <body>
    <div
       id="main"
       
    >


<header>
  <nav>
    <a href="/">Ivankovic.Me</a>
    <span id="subpages">
      <a href="/photography/">Photography</a>
      <a href="/blog/" >Blog</a>
      <a href="/contact/" >Contact</a>
      <a href="/about/" >About</a>
      <a href="/privacy/" >Privacy</a>
    </span>
  </nav>
</header>


<div id="content" style="display: block; padding-left: 64px;" itemscope itemtype="https://schema.org/BlogPosting">
  

<h1 id="raspberry-pi-minimal-network-security-setup-for-a-headless-pi">Raspberry PI - Minimal network security setup for a headless PI</h1>

<p>I run a couple of purely headless Raspberry PI units connected to my network. The following is a list of minimal security precautions I use on all units. I am using Raspbian, since it is far more stable and easier to configure securely than Arch. I would recommend everyone to install Arch at least once and play around as much as possible. But for systems you actually plan to use <sup>24</sup>&frasl;<sub>7</sub>, Raspbian is a better choice.</p>

<h2 id="password-and-user">Password and user</h2>

<p>If possible, before connecting the PI to the network you should change the default username and password. When adding the new user, don’t forget to set the appropriate groups.</p>

<pre><code>passwd
adduser -G sudo NewUserName
userdel -r pi
</code></pre>

<h2 id="remove-the-pi-user-from-the-sudoers-file">Remove the PI user from the sudoers file</h2>

<p>The pi user has passwordless access to sudo. We deleted the user already, so there is no reason to leave this in.</p>

<pre><code>sudo visudo
</code></pre>

<p>Search for</p>

<pre><code>pi ALL=(ALL) NOPASSWD: ALL
</code></pre>

<p>and remove that line.</p>

<h2 id="move-ssh-to-a-different-port">Move SSH to a different port</h2>

<p>There is a lot of controversy around this one. A lot of people claim that moving SSH to a port different from 22 is <a href="http://en.wikipedia.org/wiki/Security_through_obscurity">security through obscurity</a>. The other side is claiming, and I believe rightfully so, that it is instead <a href="http://en.wikipedia.org/wiki/Defense_in_Depth_(computing)">defense in depth</a>.</p>

<p>As anecdotal evidence, during the <a href="http://www.debian.org/security/2008/dsa-1571">2008 Debian SSL Key Generator Incident</a> servers running on standard SSH port were automatically targeted by broad sweeping scans of the entire Internet. Servers running on wacky ports were not, because it is cheaper to scan a single port when scanning the entire Internet.</p>

<p>So, move SSH to a different port. Arguably, you should choose a port lower than 1024, because these are restricted in Linux and only the root user can listen on them. However, they are also more likely to be scanned, so it’s a tradeoff.</p>

<p>Changing the SSH port is reasonably simple.</p>

<pre><code>sudo vim /etc/ssh/sshd_config
:s/Port 22/Port 1012
sudo /etc/init.d/ssh restart
</code></pre>

<p>If you were using SSH to do this, you will now be kicked out. Reconnect to the new port.</p>

<h2 id="set-up-a-simple-firewall-with-iptables">Set up a simple firewall with iptables</h2>

<p><a href="http://www.netfilter.org/">Iptables</a> is the standard way of configuring the Linux kernel firewall. Following the defense in depth principle, the firewall will be configured to stop behaviour which is <strong>definitely</strong> unnecessary for a headless SSH-only R-PI.</p>

<p><strong>If you do something wrong and lock yourself out of the PI, you can power-cycle the device and the rules will be cleared.</strong></p>

<p><strong>If you do something wrong and save the rules that lock you out, you can plug the SD card in your desktop or laptop and edit</strong> <code>/etc/iptables/rules.v4.</code></p>

<p>We start by dropping all FORWARD packets. Unless the PI is running as a router, there is no need for it to deal with these packets.</p>

<pre><code>iptables -P FORWARD DROP
</code></pre>

<p>The OUTPUT chain should default to ACCEPT. If not, this can always be ensured with:</p>

<pre><code>iptables -P OUTPUT ACCEPT
</code></pre>

<p>We allow all traffic on the loopback.</p>

<pre><code>iptables -A INPUT -i lo -j ACCEPT
</code></pre>

<p>This rule allows any packets related to existing connections. This is important because ICMP messages related to existing connections have to go through.</p>

<pre><code>iptables -A INPUT -m conntrack --ctstate RELATED,ESTABLISHED -j ACCEPT
</code></pre>

<p>If we end up with INVALID packets related to existing connections, we silently drop these.</p>

<pre><code>iptables -A INPUT -m conntrack --ctstate INVALID -j DROP
</code></pre>

<p>(<em>Optional</em>) If you would like ICMP echo (a.k.a. ping) requests to pass through the firewall, you need to add:</p>

<pre><code>iptables -A INPUT -p icmp --icmp-type 8 -m conntrack --ctstate NEW -j ACCEPT
</code></pre>

<p>It’s a good organizational idea to keep the particular service related rules in a user-defined chain.</p>

<pre><code>iptables -N TCP
</code></pre>

<p>We can send packets starting new sessions to this rule with:</p>

<pre><code>iptables -A INPUT -p tcp --syn -m conntrack --ctstate NEW -j TCP
</code></pre>

<p>Now we allow incoming connections to the SSH port (which we changed previously!):</p>

<pre><code>iptables -A TCP -p tcp -m tcp --dport 1012 -j ACCEPT
</code></pre>

<p>We can now finally drop everything else.</p>

<pre><code>iptables -P INPUT DROP
</code></pre>

<p>(<em>Optional</em>) You can make your system behave a little more friendly by adding the following two rules. They make the system RFC compliant but make the PI a bit more visible in the network because it will reject incoming connections with ICMP port unreachable or TCP RST packets. However, if you have ICMP echo packets (ping) enabled, then this doesn’t expose any new information but speeds up any clients connecting to closed ports.</p>

<pre><code>iptables -A INPUT -p tcp -j REJECT --reject-with tcp-rst
iptables -A INPUT -j REJECT --reject-with-icmp-port-unreachable
</code></pre>

<p><strong>All these changes are temporary</strong>. If you want to persist them after a reboot, install the handy iptables-persistent package:</p>

<pre><code>sudo apt-get install iptables-persistent
</code></pre>

<p>This setup is only related to the IPv4 firewall. I’ll be posting the IPv6 version once I complete it :)</p>

<h2 id="update-the-system">Update the system</h2>

<p>Do this every so often. If possible, keep track of <a href="http://downloads.raspberrypi.org/raspbian/release_notes.txt">release notes</a> from Raspbian.</p>

<pre><code>sudo apt-get update
sudo apt-get upgrade
</code></pre>

</div>

    </div>
  </body>
</html>

